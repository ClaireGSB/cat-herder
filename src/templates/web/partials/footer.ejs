    </div> <!-- container -->
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Utility functions for the dashboard
        class ClaudeDashboard {
            constructor() {
                this.websocket = null;
                this.reconnectInterval = 5000;
                this.maxReconnectAttempts = 5;
                this.reconnectAttempts = 0;
            }
            
            // Initialize WebSocket connection (for future real-time updates)
            initWebSocket() {
                if (typeof WebSocket === 'undefined') {
                    console.warn('WebSocket not supported in this browser');
                    return;
                }
                
                try {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws`;
                    
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        console.log('WebSocket connected');
                        this.reconnectAttempts = 0;
                    };
                    
                    this.websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleRealtimeUpdate(data);
                        } catch (e) {
                            console.error('Failed to parse WebSocket message:', e);
                        }
                    };
                    
                    this.websocket.onclose = () => {
                        console.log('WebSocket disconnected');
                        this.attemptReconnect();
                    };
                    
                    this.websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                    };
                } catch (error) {
                    console.error('Failed to initialize WebSocket:', error);
                }
            }
            
            // Attempt to reconnect WebSocket
            attemptReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    console.log(`Attempting to reconnect WebSocket (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                    setTimeout(() => this.initWebSocket(), this.reconnectInterval);
                }
            }
            
            // Handle real-time updates from WebSocket
            handleRealtimeUpdate(data) {
                // This will be implemented in Step 4
                console.log('Received real-time update:', data);
                
                // For now, just refresh the current page if we're on the dashboard
                if (window.location.pathname === '/') {
                    this.updateDashboardRow(data);
                } else if (window.location.pathname.startsWith('/task/')) {
                    this.updateTaskDetail(data);
                }
            }
            
            // Update a specific row in the dashboard table
            updateDashboardRow(taskData) {
                const row = document.querySelector(`tr[data-task-id="${taskData.taskId}"]`);
                if (row) {
                    // Update status badge
                    const statusBadge = row.querySelector('.status-badge');
                    if (statusBadge) {
                        statusBadge.className = `badge status-${taskData.phase} status-badge`;
                        statusBadge.textContent = taskData.phase;
                    }
                    
                    // Update duration
                    const durationCell = row.querySelector('.duration-cell');
                    if (durationCell && taskData.stats?.totalDuration) {
                        durationCell.textContent = `${taskData.stats.totalDuration.toFixed(2)}s`;
                    }
                    
                    // Update last update time
                    const updateCell = row.querySelector('.update-cell');
                    if (updateCell) {
                        updateCell.textContent = new Date(taskData.lastUpdate || Date.now()).toLocaleString();
                    }
                }
            }
            
            // Update task detail page
            updateTaskDetail(taskData) {
                // Update status in header
                const statusElement = document.querySelector('.task-status');
                if (statusElement && taskData.phase) {
                    statusElement.className = `badge status-${taskData.phase} task-status`;
                    statusElement.textContent = taskData.phase;
                }
                
                // Update stats
                if (taskData.stats) {
                    const durationElement = document.querySelector('.task-duration');
                    if (durationElement) {
                        durationElement.textContent = `${taskData.stats.totalDuration?.toFixed(2) || 'N/A'}s`;
                    }
                }
            }
            
            // Load log content asynchronously
            async loadLogContent(taskId, logFile, targetElementId) {
                const targetElement = document.getElementById(targetElementId);
                const loadingSpinner = document.getElementById('loading-spinner');
                
                if (!targetElement) {
                    console.error('Target element not found:', targetElementId);
                    return;
                }
                
                try {
                    // Show loading state
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'block';
                    }
                    targetElement.innerHTML = '<div class="text-muted p-3">Loading...</div>';
                    
                    const response = await fetch(`/log/${taskId}/${logFile}`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const content = await response.text();
                    
                    if (content.trim() === '') {
                        targetElement.innerHTML = '<div class="text-muted p-3">No log content available.</div>';
                    } else {
                        targetElement.innerHTML = `<pre class="log-content">${this.escapeHtml(content)}</pre>`;
                    }
                    
                } catch (error) {
                    console.error('Failed to load log:', error);
                    targetElement.innerHTML = `<div class="text-danger p-3">Failed to load log: ${error.message}</div>`;
                } finally {
                    // Hide loading state
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'none';
                    }
                }
            }
            
            // Escape HTML to prevent XSS
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            // Format duration in human-readable format
            formatDuration(seconds) {
                if (!seconds) return 'N/A';
                
                if (seconds < 60) {
                    return `${seconds.toFixed(1)}s`;
                } else if (seconds < 3600) {
                    const minutes = Math.floor(seconds / 60);
                    const remainingSeconds = seconds % 60;
                    return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
                } else {
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    return `${hours}h ${minutes}m`;
                }
            }
            
            // Format file size in human-readable format
            formatFileSize(bytes) {
                if (!bytes) return 'N/A';
                
                const units = ['B', 'KB', 'MB', 'GB'];
                let size = bytes;
                let unitIndex = 0;
                
                while (size >= 1024 && unitIndex < units.length - 1) {
                    size /= 1024;
                    unitIndex++;
                }
                
                return `${size.toFixed(1)} ${units[unitIndex]}`;
            }
        }
        
        // Global dashboard instance
        window.dashboard = new ClaudeDashboard();
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Auto-refresh dashboard every 30 seconds if no WebSocket
            if (window.location.pathname === '/' && !window.dashboard.websocket) {
                setInterval(() => {
                    window.location.reload();
                }, 30000);
            }
            
            // Initialize WebSocket for real-time updates (Step 4)
            // window.dashboard.initWebSocket();
        });
        
        // Expose utility functions globally for inline event handlers
        window.loadLog = function(taskId, logFile, targetElementId) {
            window.dashboard.loadLogContent(taskId, logFile, targetElementId);
        };
        
        // Handle browser back/forward navigation
        window.addEventListener('popstate', function(event) {
            // Reload page on navigation to ensure fresh data
            window.location.reload();
        });
    </script>
</body>
</html>