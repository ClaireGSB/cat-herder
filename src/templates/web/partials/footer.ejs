    </div> <!-- container -->
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Utility functions for the dashboard
        class ClaudeDashboard {
            constructor() {
                this.websocket = null;
                this.reconnectInterval = 5000;
                this.maxReconnectAttempts = 5;
                this.reconnectAttempts = 0;
            }
            
            // Initialize WebSocket connection (for future real-time updates)
            initWebSocket() {
                if (typeof WebSocket === 'undefined') {
                    console.warn('WebSocket not supported in this browser');
                    return;
                }
                
                try {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws`;
                    
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        console.log('WebSocket connected');
                        this.reconnectAttempts = 0;
                    };
                    
                    this.websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleRealtimeUpdate(data);
                        } catch (e) {
                            console.error('Failed to parse WebSocket message:', e);
                        }
                    };
                    
                    this.websocket.onclose = () => {
                        console.log('WebSocket disconnected');
                        this.attemptReconnect();
                    };
                    
                    this.websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                    };
                } catch (error) {
                    console.error('Failed to initialize WebSocket:', error);
                }
            }
            
            // Attempt to reconnect WebSocket
            attemptReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    console.log(`Attempting to reconnect WebSocket (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                    setTimeout(() => this.initWebSocket(), this.reconnectInterval);
                }
            }
            
            // Handle real-time updates from WebSocket
            handleRealtimeUpdate(data) {
                // This will be implemented in Step 4
                console.log('Received real-time update:', data);
                
                // For now, just refresh the current page if we're on the dashboard
                if (window.location.pathname === '/') {
                    this.updateDashboardRow(data);
                } else if (window.location.pathname.startsWith('/task/')) {
                    this.updateTaskDetail(data);
                }
            }
            
            // Update a specific row in the dashboard table
            updateDashboardRow(taskData) {
                const row = document.querySelector(`tr[data-task-id="${taskData.taskId}"]`);
                if (row) {
                    // Update status badge
                    const statusBadge = row.querySelector('.status-badge');
                    if (statusBadge) {
                        statusBadge.className = `badge status-${taskData.phase} status-badge`;
                        statusBadge.textContent = taskData.phase;
                    }
                    
                    // Update duration
                    const durationCell = row.querySelector('.duration-cell');
                    if (durationCell && taskData.stats?.totalDuration) {
                        durationCell.textContent = `${taskData.stats.totalDuration.toFixed(2)}s`;
                    }
                    
                    // Update last update time
                    const updateCell = row.querySelector('.update-cell');
                    if (updateCell) {
                        updateCell.textContent = new Date(taskData.lastUpdate || Date.now()).toLocaleString();
                    }
                }
            }
            
            // Update task detail page
            updateTaskDetail(taskData) {
                // Update status in header
                const statusElement = document.querySelector('.task-status');
                if (statusElement && taskData.phase) {
                    statusElement.className = `badge status-${taskData.phase} task-status`;
                    statusElement.textContent = taskData.phase;
                }
                
                // Update stats
                if (taskData.stats) {
                    const durationElement = document.querySelector('.task-duration');
                    if (durationElement) {
                        durationElement.textContent = `${taskData.stats.totalDuration?.toFixed(2) || 'N/A'}s`;
                    }
                }
            }
            
            // Load log content asynchronously
            async loadLogContent(taskId, logFile, targetElementId) {
                const targetElement = document.getElementById(targetElementId);
                const loadingSpinner = document.getElementById('loading-spinner');
                
                if (!targetElement) {
                    console.error('Target element not found:', targetElementId);
                    return;
                }
                
                try {
                    // Show loading state
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'block';
                    }
                    targetElement.innerHTML = '<div class="text-muted p-3">Loading...</div>';
                    
                    const response = await fetch(`/log/${taskId}/${logFile}`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const content = await response.text();
                    
                    if (content.trim() === '') {
                        targetElement.innerHTML = '<div class="text-muted p-3">No log content available.</div>';
                    } else {
                        targetElement.innerHTML = `<pre class="log-content">${this.escapeHtml(content)}</pre>`;
                    }
                    
                } catch (error) {
                    console.error('Failed to load log:', error);
                    targetElement.innerHTML = `<div class="text-danger p-3">Failed to load log: ${error.message}</div>`;
                } finally {
                    // Hide loading state
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'none';
                    }
                }
            }
            
            // Escape HTML to prevent XSS
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            // Format duration in human-readable format
            formatDuration(seconds) {
                if (!seconds) return 'N/A';
                
                if (seconds < 60) {
                    return `${seconds.toFixed(1)}s`;
                } else if (seconds < 3600) {
                    const minutes = Math.floor(seconds / 60);
                    const remainingSeconds = seconds % 60;
                    return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
                } else {
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    return `${hours}h ${minutes}m`;
                }
            }
            
            // Format file size in human-readable format
            formatFileSize(bytes) {
                if (!bytes) return 'N/A';
                
                const units = ['B', 'KB', 'MB', 'GB'];
                let size = bytes;
                let unitIndex = 0;
                
                while (size >= 1024 && unitIndex < units.length - 1) {
                    size /= 1024;
                    unitIndex++;
                }
                
                return `${size.toFixed(1)} ${units[unitIndex]}`;
            }
        }
        
        // Global dashboard instance
        window.dashboard = new ClaudeDashboard();
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Auto-refresh dashboard every 30 seconds if no WebSocket
            if (window.location.pathname === '/' && !window.dashboard.websocket) {
                setInterval(() => {
                    window.location.reload();
                }, 30000);
            }
            
            // Initialize WebSocket for real-time updates (Step 4)
            // window.dashboard.initWebSocket();
            
            // Live Activity page specific logic
            if (window.location.pathname === '/live') {
                initializeLiveActivity();
            }
        });
        
        // Live Activity page initialization
        function initializeLiveActivity() {
            // Get running task data from the server-rendered template
            const runningTaskData = <%-JSON.stringify(runningTask) %>;
            
            if (runningTaskData && runningTaskData.taskId && runningTaskData.currentStep) {
                // Show task info
                document.getElementById('task-info-card').style.display = 'block';
                document.getElementById('no-running-task').style.display = 'none';
                document.getElementById('live-task-id').textContent = runningTaskData.taskId;
                document.getElementById('live-task-step').textContent = runningTaskData.currentStep;
                
                // Initialize WebSocket
                window.dashboard.initWebSocket();
                
                // Set up custom message handler for live activity
                const originalOnOpen = window.dashboard.websocket ? window.dashboard.websocket.onopen : null;
                const originalOnMessage = window.dashboard.websocket ? window.dashboard.websocket.onmessage : null;
                
                // Wait for WebSocket to be initialized, then set up handlers
                setTimeout(() => {
                    if (window.dashboard.websocket) {
                        window.dashboard.websocket.onopen = function() {
                            console.log('WebSocket connected for live activity');
                            
                            // Find the reasoning log file for the current step
                            const stepLog = runningTaskData.logs && runningTaskData.logs[runningTaskData.currentStep];
                            if (stepLog && stepLog.reasoning) {
                                const message = {
                                    type: 'watch_log',
                                    taskId: runningTaskData.taskId,
                                    logFile: stepLog.reasoning
                                };
                                window.dashboard.websocket.send(JSON.stringify(message));
                            }
                        };

                        window.dashboard.websocket.onmessage = function(event) {
                            try {
                                const data = JSON.parse(event.data);
                                const logContainer = document.getElementById('live-log-content');

                                if (data.type === 'log_content') {
                                    // Initial log content
                                    logContainer.textContent = data.content;
                                    // Auto-scroll to the bottom
                                    logContainer.parentElement.scrollTop = logContainer.parentElement.scrollHeight;
                                } else if (data.type === 'log_update') {
                                    // New log content
                                    logContainer.textContent += data.content;
                                    // Auto-scroll to the bottom
                                    logContainer.parentElement.scrollTop = logContainer.parentElement.scrollHeight;
                                } else if (data.type === 'error') {
                                    console.error('WebSocket error:', data.message);
                                    logContainer.textContent += '\n[ERROR: ' + data.message + ']\n';
                                }
                            } catch (e) {
                                console.error('Failed to parse WebSocket message:', e);
                            }
                        };
                        
                        // Trigger connection if not already connected
                        if (window.dashboard.websocket.readyState === WebSocket.CONNECTING || window.dashboard.websocket.readyState === WebSocket.OPEN) {
                            if (window.dashboard.websocket.readyState === WebSocket.OPEN) {
                                window.dashboard.websocket.onopen();
                            }
                        }
                    }
                }, 100);
            } else {
                // No running task, show message
                document.getElementById('task-info-card').style.display = 'none';
                document.getElementById('no-running-task').style.display = 'block';
                document.getElementById('live-log-content').textContent = 'No active task to monitor.\n\nStart a task with:\nclaud-project run your-task.md\n\nThen refresh this page to see live logs.';
            }
        }
        
        // Expose utility functions globally for inline event handlers
        window.loadLog = function(taskId, logFile, targetElementId) {
            window.dashboard.loadLogContent(taskId, logFile, targetElementId);
        };
        
        // Handle browser back/forward navigation
        window.addEventListener('popstate', function(event) {
            // Reload page on navigation to ensure fresh data
            window.location.reload();
        });
    </script>
</body>
</html>