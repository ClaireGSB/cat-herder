    </div> <!-- container -->
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Utility functions for the dashboard
        class ClaudeDashboard {
            constructor() {
                this.websocket = null;
                this.reconnectInterval = 5000;
                this.maxReconnectAttempts = 5;
                this.reconnectAttempts = 0;
            }
            
            // Initialize WebSocket connection (for future real-time updates)
            initWebSocket() {
                if (typeof WebSocket === 'undefined') {
                    console.warn('WebSocket not supported in this browser');
                    return;
                }
                
                try {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws`;
                    
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        console.log('WebSocket connected');
                        this.reconnectAttempts = 0;
                    };
                    
                    this.websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleRealtimeUpdate(data);
                        } catch (e) {
                            console.error('Failed to parse WebSocket message:', e);
                        }
                    };
                    
                    this.websocket.onclose = () => {
                        console.log('WebSocket disconnected');
                        this.attemptReconnect();
                    };
                    
                    this.websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                    };
                } catch (error) {
                    console.error('Failed to initialize WebSocket:', error);
                }
            }
            
            // Attempt to reconnect WebSocket
            attemptReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    console.log(`Attempting to reconnect WebSocket (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                    setTimeout(() => this.initWebSocket(), this.reconnectInterval);
                }
            }
            
            // Handle real-time updates from WebSocket
            handleRealtimeUpdate(data) {
                console.log('Received real-time update:', data);
                
                // Handle different message types
                if (data.type === 'task_update') {
                    // Handle task state updates
                    if (window.location.pathname === '/') {
                        this.updateDashboardRow(data.data);
                    } else if (window.location.pathname.startsWith('/task/')) {
                        this.updateTaskDetail(data.data);
                    }
                } else if (data.type === 'sequence_update') {
                    // Handle sequence state updates
                    console.log('Sequence update received:', data.data);
                    if (window.location.pathname === '/sequences') {
                        this.updateSequencesDashboardRow(data.data);
                    } else if (window.location.pathname.startsWith('/sequence/')) {
                        this.updateSequenceDetail(data.data);
                    }
                } else if (data.type === 'log_content' || data.type === 'log_update' || data.type === 'error') {
                    // These are handled by page-specific logic (live activity)
                    return;
                } else {
                    // Legacy support - treat as task update for backwards compatibility
                    if (window.location.pathname === '/') {
                        this.updateDashboardRow(data);
                    } else if (window.location.pathname.startsWith('/task/')) {
                        this.updateTaskDetail(data);
                    }
                }
            }
            
            // Update a specific row in the dashboard table
            updateDashboardRow(taskData) {
                const row = document.querySelector(`tr[data-task-id="${taskData.taskId}"]`);
                if (row) {
                    // Update status badge
                    const statusBadge = row.querySelector('.status-badge');
                    if (statusBadge) {
                        statusBadge.className = `badge status-${taskData.phase} status-badge`;
                        statusBadge.textContent = taskData.phase;
                    }
                    
                    // Update duration
                    const durationCell = row.querySelector('.duration-cell');
                    if (durationCell && taskData.stats?.totalDuration) {
                        durationCell.textContent = `${taskData.stats.totalDuration.toFixed(2)}s`;
                    }
                    
                    // Update last update time
                    const updateCell = row.querySelector('.update-cell');
                    if (updateCell) {
                        updateCell.textContent = new Date(taskData.lastUpdate || Date.now()).toLocaleString();
                    }
                }
            }
            
            // Update task detail page
            updateTaskDetail(taskData) {
                // Update status in header
                const statusElement = document.querySelector('.task-status');
                if (statusElement && taskData.phase) {
                    statusElement.className = `badge status-${taskData.phase} task-status`;
                    statusElement.textContent = taskData.phase;
                }
                
                // Update stats
                if (taskData.stats) {
                    const durationElement = document.querySelector('.task-duration');
                    if (durationElement) {
                        durationElement.textContent = `${taskData.stats.totalDuration?.toFixed(2) || 'N/A'}s`;
                    }
                }
            }
            
            // Update a specific row in the sequences dashboard table
            updateSequencesDashboardRow(sequenceData) {
                const row = document.querySelector(`tr[data-sequence-id="${sequenceData.sequenceId}"]`);
                if (row) {
                    // Update status badge
                    const statusBadge = row.querySelector('.status-badge');
                    if (statusBadge) {
                        statusBadge.className = `badge status-${sequenceData.phase} status-badge`;
                        
                        // Update icon
                        let iconHtml = '';
                        if (sequenceData.phase === 'running') {
                            iconHtml = '<i class="bi bi-arrow-repeat spinner-border spinner-border-sm me-1" role="status"></i>';
                        } else if (sequenceData.phase === 'done') {
                            iconHtml = '<i class="bi bi-check-circle-fill me-1"></i>';
                        } else if (sequenceData.phase === 'failed') {
                            iconHtml = '<i class="bi bi-exclamation-triangle-fill me-1"></i>';
                        } else if (sequenceData.phase === 'paused') {
                            iconHtml = '<i class="bi bi-pause-circle-fill me-1"></i>';
                        }
                        statusBadge.innerHTML = iconHtml + sequenceData.phase;
                    }
                    
                    // Update duration
                    const durationCell = row.querySelector('.duration-cell');
                    if (durationCell && sequenceData.stats?.totalDuration) {
                        durationCell.innerHTML = `${sequenceData.stats.totalDuration.toFixed(2)}s`;
                        if (sequenceData.stats.totalPauseTime && sequenceData.stats.totalPauseTime > 0) {
                            durationCell.innerHTML += `<br><small class="text-warning"><i class="bi bi-pause-fill"></i> ${sequenceData.stats.totalPauseTime.toFixed(2)}s paused</small>`;
                        }
                    }
                    
                    // Update last update time
                    const updateCell = row.querySelector('.update-cell');
                    if (updateCell) {
                        updateCell.textContent = new Date(sequenceData.lastUpdate || Date.now()).toLocaleString();
                    }
                }
                
                // Update summary cards at top of page
                this.updateSequenceSummaryCards(sequenceData.phase);
            }
            
            // Update sequence detail page
            updateSequenceDetail(sequenceData) {
                // Update status in header
                const statusElement = document.querySelector('.sequence-status');
                if (statusElement && sequenceData.phase) {
                    statusElement.className = `badge status-${sequenceData.phase} fs-6 sequence-status`;
                    
                    // Update icon
                    let iconHtml = '';
                    if (sequenceData.phase === 'running') {
                        iconHtml = '<i class="bi bi-arrow-repeat spinner-border spinner-border-sm me-1" role="status"></i>';
                    } else if (sequenceData.phase === 'done') {
                        iconHtml = '<i class="bi bi-check-circle-fill me-1"></i>';
                    } else if (sequenceData.phase === 'failed') {
                        iconHtml = '<i class="bi bi-exclamation-triangle-fill me-1"></i>';
                    } else if (sequenceData.phase === 'paused') {
                        iconHtml = '<i class="bi bi-pause-circle-fill me-1"></i>';
                    }
                    statusElement.innerHTML = iconHtml + sequenceData.phase;
                }
                
                // Update stats
                if (sequenceData.stats) {
                    const durationElement = document.querySelector('.sequence-duration');
                    if (durationElement) {
                        durationElement.textContent = `${sequenceData.stats.totalDuration?.toFixed(2) || 'N/A'}s`;
                    }
                }
            }
            
            // Update summary cards on sequences dashboard
            updateSequenceSummaryCards(changedPhase) {
                // This is a simplified approach - in a real implementation,
                // we would want to fetch fresh counts from the server
                // For now, we'll just trigger a subtle refresh indicator
                const refreshIcon = document.querySelector('.bi-arrow-clockwise');
                if (refreshIcon) {
                    refreshIcon.style.animation = 'spin 1s linear';
                    setTimeout(() => {
                        refreshIcon.style.animation = '';
                    }, 1000);
                }
            }
            
            // Load log content asynchronously
            async loadLogContent(taskId, logFile, targetElementId) {
                const targetElement = document.getElementById(targetElementId);
                const loadingSpinner = document.getElementById('loading-spinner');
                
                if (!targetElement) {
                    console.error('Target element not found:', targetElementId);
                    return;
                }
                
                try {
                    // Show loading state
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'block';
                    }
                    targetElement.innerHTML = '<div class="text-muted p-3">Loading...</div>';
                    
                    const response = await fetch(`/log/${taskId}/${logFile}`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const content = await response.text();
                    
                    if (content.trim() === '') {
                        targetElement.innerHTML = '<div class="text-muted p-3">No log content available.</div>';
                    } else {
                        targetElement.innerHTML = `<pre class="log-content">${this.escapeHtml(content)}</pre>`;
                    }
                    
                } catch (error) {
                    console.error('Failed to load log:', error);
                    targetElement.innerHTML = `<div class="text-danger p-3">Failed to load log: ${error.message}</div>`;
                } finally {
                    // Hide loading state
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'none';
                    }
                }
            }
            
            // Escape HTML to prevent XSS
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            // Format duration in human-readable format
            formatDuration(seconds) {
                if (!seconds) return 'N/A';
                
                if (seconds < 60) {
                    return `${seconds.toFixed(1)}s`;
                } else if (seconds < 3600) {
                    const minutes = Math.floor(seconds / 60);
                    const remainingSeconds = seconds % 60;
                    return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
                } else {
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    return `${hours}h ${minutes}m`;
                }
            }
            
            // Format file size in human-readable format
            formatFileSize(bytes) {
                if (!bytes) return 'N/A';
                
                const units = ['B', 'KB', 'MB', 'GB'];
                let size = bytes;
                let unitIndex = 0;
                
                while (size >= 1024 && unitIndex < units.length - 1) {
                    size /= 1024;
                    unitIndex++;
                }
                
                return `${size.toFixed(1)} ${units[unitIndex]}`;
            }
        }
        
        // Global dashboard instance
        window.dashboard = new ClaudeDashboard();
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Auto-refresh dashboard every 30 seconds if no WebSocket
            if (window.location.pathname === '/' && !window.dashboard.websocket) {
                setInterval(() => {
                    window.location.reload();
                }, 30000);
            }
            
            // Initialize WebSocket for real-time updates
            window.dashboard.initWebSocket();
            
            // Live Activity page specific logic
            if (window.location.pathname === '/live') {
                initializeLiveActivity();
            }
        });
        
        // Live Activity page initialization
        function initializeLiveActivity() {
            // Get running task data from the server-rendered template
            const runningTaskData = <%- typeof runningTask !== 'undefined' && runningTask ? JSON.stringify(runningTask) : 'null' %>;
            const parentSequenceData = <%- typeof parentSequence !== 'undefined' && parentSequence ? JSON.stringify(parentSequence) : 'null' %>;
            
            if (runningTaskData && runningTaskData.taskId && runningTaskData.currentStep) {
                // Show task info
                document.getElementById('task-info-card').style.display = 'block';
                document.getElementById('no-running-task').style.display = 'none';
                document.getElementById('live-task-id').textContent = runningTaskData.taskId;
                document.getElementById('live-task-step').textContent = runningTaskData.currentStep;
                
                // Show sequence info if task is part of a sequence
                if (parentSequenceData && parentSequenceData.sequenceId) {
                    document.getElementById('sequence-info-card').style.display = 'block';
                    document.getElementById('live-sequence-id').textContent = parentSequenceData.sequenceId;
                    document.getElementById('live-sequence-status').textContent = parentSequenceData.phase || 'unknown';
                    
                    // Update sequence status badge color
                    const statusBadge = document.getElementById('live-sequence-status');
                    statusBadge.className = 'badge bg-secondary';
                    if (parentSequenceData.phase === 'running') {
                        statusBadge.className = 'badge bg-primary';
                    } else if (parentSequenceData.phase === 'done') {
                        statusBadge.className = 'badge bg-success';
                    } else if (parentSequenceData.phase === 'failed') {
                        statusBadge.className = 'badge bg-danger';
                    }
                } else {
                    document.getElementById('sequence-info-card').style.display = 'none';
                }
                
                // Validate log data exists before attempting to connect
                const stepLog = runningTaskData.logs && runningTaskData.logs[runningTaskData.currentStep];
                if (!stepLog || !stepLog.reasoning) {
                    const logContainer = document.getElementById('live-log-content');
                    logContainer.textContent = 'No reasoning log available for current step: ' + runningTaskData.currentStep;
                    return;
                }
                
                // Initialize WebSocket with live activity setup
                initLiveActivityWebSocket(runningTaskData, parentSequenceData, stepLog.reasoning);
            } else {
                // No running task, show message
                document.getElementById('task-info-card').style.display = 'none';
                document.getElementById('sequence-info-card').style.display = 'none';
                document.getElementById('no-running-task').style.display = 'block';
                document.getElementById('live-log-content').textContent = 'No active task to monitor.\n\nStart a task with:\nclaud-project run your-task.md\n\nThen refresh this page to see live logs.';
            }
        }
        
        // Initialize WebSocket specifically for live activity log streaming
        function initLiveActivityWebSocket(runningTaskData, parentSequenceData, reasoningLogFile) {
            try {
                // Initialize the WebSocket connection
                window.dashboard.initWebSocket();
                
                // Wait for WebSocket to be ready, then set up live activity handlers
                const waitForConnection = () => {
                    if (window.dashboard.websocket && window.dashboard.websocket.readyState === WebSocket.OPEN) {
                        setupLiveActivityHandlers(runningTaskData, parentSequenceData, reasoningLogFile);
                    } else if (window.dashboard.websocket && window.dashboard.websocket.readyState === WebSocket.CONNECTING) {
                        // Wait for connection to open
                        window.dashboard.websocket.addEventListener('open', () => {
                            setupLiveActivityHandlers(runningTaskData, parentSequenceData, reasoningLogFile);
                        });
                    } else {
                        // Retry after a short delay
                        setTimeout(waitForConnection, 100);
                    }
                };
                
                waitForConnection();
                
            } catch (error) {
                console.error('Failed to initialize WebSocket for live activity:', error);
                const logContainer = document.getElementById('live-log-content');
                logContainer.textContent = 'Failed to connect to live log stream: ' + error.message;
            }
        }
        
        // Set up WebSocket message handlers for live activity
        function setupLiveActivityHandlers(runningTaskData, parentSequenceData, reasoningLogFile) {
            const logContainer = document.getElementById('live-log-content');
            
            // Override the WebSocket message handler for live activity
            window.dashboard.websocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'log_content') {
                        // Initial log content
                        logContainer.textContent = data.content;
                        autoScrollToBottom();
                    } else if (data.type === 'log_update') {
                        // New log content
                        logContainer.textContent += data.content;
                        autoScrollToBottom();
                    } else if (data.type === 'task_update' && data.data.taskId === runningTaskData.taskId) {
                        // Handle task status updates
                        if (data.data.phase !== 'running') {
                            logContainer.textContent += `\n\n--- TASK FINISHED with status: ${data.data.phase} ---`;
                            autoScrollToBottom();
                            
                            // Show task finished banner if no sequence is involved
                            if (!parentSequenceData) {
                                const taskBanner = document.getElementById('task-finished-banner');
                                const taskDetailsLink = document.getElementById('view-task-details-link');
                                taskDetailsLink.href = `/task/${runningTaskData.taskId}`;
                                taskBanner.style.display = 'block';
                            }
                        }
                        
                        // Update current step if provided
                        if (data.data.currentStep) {
                            document.getElementById('live-task-step').textContent = data.data.currentStep;
                        }
                    } else if (parentSequenceData && data.type === 'sequence_update' && data.data.sequenceId === parentSequenceData.sequenceId) {
                        // Handle sequence status updates
                        const sequenceStatusBadge = document.getElementById('live-sequence-status');
                        if (sequenceStatusBadge) {
                            sequenceStatusBadge.textContent = data.data.phase || 'unknown';
                            
                            // Update badge color
                            sequenceStatusBadge.className = 'badge bg-secondary';
                            if (data.data.phase === 'running') {
                                sequenceStatusBadge.className = 'badge bg-primary';
                            } else if (data.data.phase === 'done') {
                                sequenceStatusBadge.className = 'badge bg-success';
                            } else if (data.data.phase === 'failed') {
                                sequenceStatusBadge.className = 'badge bg-danger';
                            }
                        }
                        
                        // Handle sequence completion
                        if (data.data.phase !== 'running') {
                            logContainer.textContent += `\n\n--- SEQUENCE FINISHED with status: ${data.data.phase} ---`;
                            autoScrollToBottom();
                            
                            // Show sequence finished banner and hide task banner
                            const seqBanner = document.getElementById('sequence-finished-banner');
                            const seqDetailsLink = document.getElementById('view-sequence-details-link');
                            seqDetailsLink.href = `/sequence/${parentSequenceData.sequenceId}`;
                            seqBanner.style.display = 'block';
                            
                            // Hide the individual task finished banner
                            document.getElementById('task-finished-banner').style.display = 'none';
                        }
                    } else if (data.type === 'error') {
                        console.error('WebSocket error:', data.message);
                        logContainer.textContent += '\n[ERROR: ' + data.message + ']\n';
                        autoScrollToBottom();
                    }
                } catch (e) {
                    console.error('Failed to parse WebSocket message:', e);
                    logContainer.textContent += '\n[ERROR: Failed to parse message]\n';
                    autoScrollToBottom();
                }
            };
            
            // Request to start watching the log file
            const watchMessage = {
                type: 'watch_log',
                taskId: runningTaskData.taskId,
                logFile: reasoningLogFile
            };
            
            window.dashboard.websocket.send(JSON.stringify(watchMessage));
            console.log('Watching log file:', reasoningLogFile, 'for task:', runningTaskData.taskId);
        }
        
        // Helper function to auto-scroll to bottom of log content
        function autoScrollToBottom() {
            const logContainer = document.getElementById('live-log-content');
            if (logContainer && logContainer.parentElement) {
                logContainer.parentElement.scrollTop = logContainer.parentElement.scrollHeight;
            }
        }
        
        // Expose utility functions globally for inline event handlers
        window.loadLog = function(taskId, logFile, targetElementId) {
            window.dashboard.loadLogContent(taskId, logFile, targetElementId);
        };
        
        // Handle browser back/forward navigation
        window.addEventListener('popstate', function(event) {
            // Reload page on navigation to ensure fresh data
            window.location.reload();
        });
    </script>
</body>
</html>